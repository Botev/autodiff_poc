//
// Created by alex on 20/02/16.
//

// Auto generated by Metadiff
// Please do not edit

#include "vector"
#include "memory"
#include <exception>
#include <arrayfire.h>

class InvalidInputShape : public std::exception {
public:
    size_t id;
    size_t expected[4];
    size_t given[4];
    std::string msg;

    InvalidInputShape(size_t id,
                      size_t  expected[4],
                      size_t  given[4]) :
            id(id){
        for(int i=0;i<4;i++){
            this->expected[i] = expected[i];
            this->given[i] = given[i];
        }
        msg = "The input node with id " + std::to_string(id) + " provided has incorrect shape.\n" +
              "Expected:" + std::to_string(expected[0]) + ", " + std::to_string(expected[1]) + ", "
              + std::to_string(expected[2]) + ", " + std::to_string(expected[3]) + ", " + "\n" +
              "Given:   " + std::to_string(given[0]) + ", " + std::to_string(given[1]) + ", "
              + std::to_string(given[2]) + ", " + std::to_string(given[3]) + ", " + "\n";
    };

    const char *what() const throw() {
        return msg.c_str();
    }
};

class SharedVariable{
public:
    size_t id;
    af::array value;
    SharedVariable():
            id(0),
            value(af::array())
    {};
    SharedVariable(size_t id, af::array value):
            id(id),
            value(value)
    {};
};
typedef std::shared_ptr<SharedVariable> SharedPtr;
void print_mem_info(std::string name){
    size_t alloc_bytes,alloc_buffers,lock_bytes,lock_buffers;
    af::deviceMemInfo(&alloc_bytes,&alloc_buffers,&lock_bytes,&lock_buffers);
    std::cout << "Memory info" << name << std::endl;
    std::cout << "Allocated: " << alloc_bytes / 1024 << " KB" << std::endl;
    std::cout << "Buffers allocated: " << alloc_buffers << std::endl;
    std::cout << "In use: " << lock_bytes / 1024 << " KB" << std::endl;
    std::cout << "Buffers in use: " << lock_buffers << std::endl;
    return;
};

inline af::array softplus(af::array input, int threshold) {
    af::array result = af::log1p(af::exp(input));
    af::replace(result, input < threshold, input);
    return result;
}

extern "C" std::vector<af::array> eval_func(std::vector<af::array>& inputs, std::vector<SharedPtr>& shared_vars){
    // Set up automatic broadcasting
    af::gforSet(true);

    // Calculate all of the computation nodes
    af::array node_20 = af::tanh((af::matmul(shared_vars[0]->value, inputs[0], AF_MAT_NONE, AF_MAT_NONE) + shared_vars[1]->value));
    af::array node_24 = af::tanh((af::matmul(shared_vars[2]->value, node_20, AF_MAT_NONE, AF_MAT_NONE) + shared_vars[3]->value));
    af::array node_28 = af::tanh((af::matmul(shared_vars[4]->value, node_24, AF_MAT_NONE, AF_MAT_NONE) + shared_vars[5]->value));
    af::array node_32 = af::tanh((af::matmul(shared_vars[6]->value, node_28, AF_MAT_NONE, AF_MAT_NONE) + shared_vars[7]->value));
    af::array node_36 = af::tanh((af::matmul(shared_vars[8]->value, node_32, AF_MAT_NONE, AF_MAT_NONE) + shared_vars[9]->value));
    af::array node_40 = af::tanh((af::matmul(shared_vars[10]->value, node_36, AF_MAT_NONE, AF_MAT_NONE) + shared_vars[11]->value));
    af::array node_44 = af::tanh((af::matmul(shared_vars[12]->value, node_40, AF_MAT_NONE, AF_MAT_NONE) + shared_vars[13]->value));
    af::array node_47 = (af::matmul(shared_vars[14]->value, node_44, AF_MAT_NONE, AF_MAT_NONE) + shared_vars[15]->value);
    af::array node_54 = af::exp((-node_47));
    af::array node_72 = 0.001000 * (1.0 / (1.0 + node_54) - inputs[0]);
    af::array node_82 = af::matmul(shared_vars[14]->value, node_72, AF_MAT_TRANS, AF_MAT_NONE) * (1.0 - node_44 * node_44);
    af::array node_92 = af::matmul(shared_vars[12]->value, node_82, AF_MAT_TRANS, AF_MAT_NONE) * (1.0 - node_40 * node_40);
    af::array node_102 = af::matmul(shared_vars[10]->value, node_92, AF_MAT_TRANS, AF_MAT_NONE) * (1.0 - node_36 * node_36);
    af::array node_112 = af::matmul(shared_vars[8]->value, node_102, AF_MAT_TRANS, AF_MAT_NONE) * (1.0 - node_32 * node_32);
    af::array node_122 = af::matmul(shared_vars[6]->value, node_112, AF_MAT_TRANS, AF_MAT_NONE) * (1.0 - node_28 * node_28);
    af::array node_132 = af::matmul(shared_vars[4]->value, node_122, AF_MAT_TRANS, AF_MAT_NONE) * (1.0 - node_24 * node_24);
    af::array node_142 = af::matmul(shared_vars[2]->value, node_132, AF_MAT_TRANS, AF_MAT_NONE) * (1.0 - node_20 * node_20);

    // Update all shared variables
    shared_vars[0]->value -= 0.010000 * af::matmul(node_142, inputs[0], AF_MAT_NONE, AF_MAT_TRANS);
    shared_vars[1]->value -= 0.010000 * af::sum(node_142, 1);
    shared_vars[2]->value -= 0.010000 * af::matmul(node_132, node_20, AF_MAT_NONE, AF_MAT_TRANS);
    shared_vars[3]->value -= 0.010000 * af::sum(node_132, 1);
    shared_vars[4]->value -= 0.010000 * af::matmul(node_122, node_24, AF_MAT_NONE, AF_MAT_TRANS);
    shared_vars[5]->value -= 0.010000 * af::sum(node_122, 1);
    shared_vars[6]->value -= 0.010000 * af::matmul(node_112, node_28, AF_MAT_NONE, AF_MAT_TRANS);
    shared_vars[7]->value -= 0.010000 * af::sum(node_112, 1);
    shared_vars[8]->value -= 0.010000 * af::matmul(node_102, node_32, AF_MAT_NONE, AF_MAT_TRANS);
    shared_vars[9]->value -= 0.010000 * af::sum(node_102, 1);
    shared_vars[10]->value -= 0.010000 * af::matmul(node_92, node_36, AF_MAT_NONE, AF_MAT_TRANS);
    shared_vars[11]->value -= 0.010000 * af::sum(node_92, 1);
    shared_vars[12]->value -= 0.010000 * af::matmul(node_82, node_40, AF_MAT_NONE, AF_MAT_TRANS);
    shared_vars[13]->value -= 0.010000 * af::sum(node_82, 1);
    shared_vars[14]->value -= 0.010000 * af::matmul(node_72, node_44, AF_MAT_NONE, AF_MAT_TRANS);
    shared_vars[15]->value -= 0.010000 * af::sum(node_72, 1);
    af::gforSet(false);
    // Write all of the output nodes in correct order
    return {af::sum(af::flat(inputs[0] * af::select((-node_47) > 50.000000, (-node_47), af::log1p(node_54)) + (float(1.0) - inputs[0]) * af::select(node_47 > 50.000000, node_47, af::log1p(af::exp(node_47))))) * 0.001000};
}

int main(){
    af::array a = af::constant(21,3,5);
    SharedPtr b = std::make_shared<SharedVariable>();
    std::vector<af::array> x = {a};
    std::vector<SharedPtr> y = {b};
    eval_func(x,y);
}

