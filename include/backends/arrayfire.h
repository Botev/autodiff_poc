//
// Created by alex on 18/12/15.
//

#ifndef AUTODIFF_BACKENDS_ARRAYFIRE_H
#define AUTODIFF_BACKENDS_ARRAYFIRE_H

#include <fstream>
namespace metadiff{
    class ArrayfireBackend: public FunctionBackend<af::array>{
    public:
        std::string include_path;
        ArrayfireBackend(std::string include_path):
                include_path(include_path)
        {};

        static void print_node(std::ofstream& f, Graph graph, size_t id);
        void print_symbolics(std::ofstream& f, Graph graph, std::vector<Node> inputs);
        void generate_source(std::string file_name, Graph graph,
                             std::vector<Node> inputs,
                             std::vector<Node> targets) {
            std::ofstream f;
            f.open(file_name);
            f << "// Auto generated by Metadiff\n// Please do not edit\n\n";
            f << "#include <arrayfire.h>\n\n";
            f << "using namespace af;\n\n";
            f << "extern \"C\" std::vector<af::array> eval_func(std::vector<af::array> inputs){\n";
            f << "\tstd::vector<af::array> outputs;\n";
            // Get ancestors mask
            auto ancestor_mask = graph->get_ancestors_mask(targets);
            // Check that all inputs required are given
            for(int i=0;i<ancestor_mask.size();i++){
                if(ancestor_mask[i] and graph->nodes[i]->type == INPUT){
                    for(int j=0;j<=inputs.size();j++){
                        if(j == inputs.size()){
                            throw MissingRequiredInput(targets, i);
                        }
                        if(inputs[j].id == i){
                            break;
                        }
                    }
                }
            }

            // Write all of the input nodes
            f << "\n\t// Set all of the inputs accordingly\n";
            for(int i=0;i<inputs.size();i++){
                f << "\taf::array node_" << inputs[i].id << " = inputs[" << i << "];\n";
            }

            print_symbolics(f, graph, inputs);

            // Write all of the other nodes
            f << "\n\t// Calculate all of the computation nodes\n";
            for(int i=0;i<ancestor_mask.size();i++){
                if(ancestor_mask[i] and graph->nodes[i]->type != INPUT){
                    print_node(f, graph, i);
                }
            }

//            f << "std::cout << \"End\" << std::endl;\n";

            // Write all of the output nodes as the result
            f << "\n\t// Write all of the output nodes in correct order\n";
            f << "\treturn {";
            for(int i=0;i<targets.size();i++){
                if(i < targets.size() - 1){
                    f << "node_" << targets[i].id << ", ";
                } else {
                    f << "node_" << targets[i].id << "};\n";
                }
            }
            f << "}\n";
            f.close();
        }

        void compile_file(std::string file_name, std::string dll_name){
            std::string command = "g++ -Wall -shared -fPIC -std=c++11 -Werror=return-type -Wno-unused-variable -I" + include_path;
            command += " -o " + dll_name + " " + file_name;
            std::cout << "Command: " << command << std::endl;
            std::cout << "Compilation response: " << system(command.c_str()) << std::endl;
            return;
        }
    };

    void ArrayfireBackend::print_symbolics(std::ofstream& f, Graph graph, std::vector<Node> inputs){
        f << "\n\t// Set all of the symbolic variables\n";
        for(size_t i=0;i<graph->sym_integer_count;i++){
            SymInt variable = SymInt::variable(i);
            f << "\tint " << variable << " = ";
            bool done = false;
            for(int j=0;j<inputs.size();j++){
                auto shape = graph->nodes[inputs[j].id]->shape;
                for(int s=0;s<4;s++){
                    if(shape[s] == variable){
                        f << "node_" << inputs[j].id << ".dims(" << s << ")";
                        done = true;
                        break;
                    }
                }
                if(done){
                    break;
                }
            }
            f << ";\n";
        }
    }

    void ArrayfireBackend::print_node(std::ofstream& f, Graph graph, size_t id){
//        f << "\tstd::cout << \"Node \" << " << id << " << std::endl;\n";
        auto node = graph->nodes[id];
        auto op_name = node->op->name;
        auto parents = node->op->get_parents();
        auto args = node->op->get_arguments();
//        f << "\tstd::cout << \"Parents dims: \" << ";
//        for(int i=0;i<parents.size();i++){
//            if(not parents[i].lock()->is_constant()) {
//                f << "node_" << parents[i].lock()->id << ".dims() << \"|\" << ";
//            }
//        }
//        f << "std::endl;\n";

        if(node->type == CONSTANT and node->op->name == "Input"){
            if(node->v_type == FLOAT) {
                f << "\tfloat node_" << id << " = " << node->value.num_value << ";\n";
            } else if(node->v_type == INTEGER){
                f << "\tfloat node_" << id << " = " << ((int)node->value.num_value) << ";\n";
            } else {
                f << "\tfloat node_" << id << " = " << ((bool)node->value.num_value) << ";\n";
            }
        } else {
            f << "\taf::array node_" << id << " = ";
            if (op_name == "Broadcast") {
                auto parent = parents[0].lock();
                f << "af::tile(node_" << parent->id << ", ";
                for (int i = 0; i < 4; i++) {
                    if (node->shape[i] != parent->shape[i]) {
                        f << node->shape[i].to_string_with_star();
                    } else {
                        f << "1";
                    }
                    if (i < 3) {
                        f << ", ";
                    }
                }
                f << ")";
            } else if (op_name == "Sum") {
                auto parent = parents[0].lock();
                auto axes = dynamic_cast<Sum *>(node->op.get())->axes;
                std::string code = "node_" + std::to_string(parent->id);
                for (int i = 0; i < axes.size(); i++) {
                    if (parent->shape[axes[i]] != 1) {
                        code = "af::sum(" + code + ", " + std::to_string(axes[i]) + ")";
                    }
                }
                f << code;
            } else if (op_name == "Add") {
                for (int i = 0; i < parents.size(); i++) {
                    f << "node_" << parents[i].lock()->id;
                    if (i < parents.size() - 1) {
                        f << " + ";
                    }
                }
            } else if (op_name == "Neg") {
                f << "- node_" << parents[0].lock()->id << "";
            } else if (op_name == "Mul") {
                for (int i = 0; i < parents.size(); i++) {
                    f << "node_" << parents[i].lock()->id;
                    if (i < parents.size() - 1) {
                        f << " * ";
                    }
                }
            } else if (op_name == "Div") {
                f << "1 / node_" << parents[0].lock()->id << "";
            } else if (op_name == "Square") {
                f << "node_" << parents[0].lock()->id << " * "
                << parents[0].lock()->id << "";
            } else if (op_name == "Transpose") {
                f << "af::transpose(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "MatrixMul") {
                f << "af::matmul(";
                for (int i = 0; i < parents.size(); i++) {
                    f << "node_" << parents[i].lock()->id;
                    if (i < parents.size() - 1) {
                        f << ", ";
                    }
                }
                f << ")";
            } else if (op_name == "MatrixInv") {
                f << "af::inverse(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Det") {
                f << "af::det(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "LogDet") {
                f << "af::log(af::det(node_" << parents[0].lock()->id << "))";
            } else if (op_name == "Trace") {

            } else if (op_name == "Exp") {
                f << "af::exp(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Log") {
                f << "af::log(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Pow") {

            } else if (op_name == "Abs") {
                f << "af::abs(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Sin") {
                f << "af::sin(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Cos") {
                f << "af::cos(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Tan") {
                f << "af::tan(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Cot") {
                f << "af::cot(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Sinh") {
                f << "af::sinh(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Cosh") {
                f << "af::cosh(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Tanh") {
                f << "af::tanh(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Coth") {
                f << "af::coth(node_" << parents[0].lock()->id << ")";
            } else if (op_name == "Diag") {
                if (node->shape[1] == 1) {
                    f << "af::diag(node_" << parents[0].lock()->id << ", 0, true)";
                } else {
                    f << "af::diag(node_" << parents[0].lock()->id << ", 0, false)";
                }
            } else if (op_name == "Reshape") {
                f << "af::moddims(node_" << parents[0].lock()->id << ", ";
                for (int i = 0; i < 4; i++) {
                    f << node->shape[i].to_string_with_star();
                    if (i < 3) {
                        f << ", ";
                    }
                }
                f << ")";
            } else if (op_name == "Reorder") {
                f << "af::reorder(node_" << parents[0].lock()->id << ", ";
                auto op_1 = dynamic_cast<Reorder *>(node->op.get());
                auto order = op_1->order;
                for (int i = 0; i < 4; i++) {
                    f << order[i];
                    if (i < 3) {
                        f << ", ";
                    }
                }
                f << ")";
            } else if (op_name == "MaxAndArgMax") {

            } else if (op_name == "SortAndArgSort") {

            } else if (op_name == "Eye") {

            } else if (op_name == "Gt") {

            } else if (op_name == "Ge") {

            } else if (op_name == "Lt") {

            } else if (op_name == "Le") {

            } else if (op_name == "Eq") {

            } else if (op_name == "Ne") {

            } else if (op_name == "ApproxEq") {

            } else if (op_name == "ApproxNe") {

            } else if (op_name == "ZeroElem") {

            } else if (op_name == "NonZeroElem") {

            } else if (op_name == "IsNaN") {

            } else if (op_name == "IsInf") {

            } else {
                f << "WTF";
            }
            f << ";\n";
        }
    }

}

#endif //AUTODIFF_BACKENDS_ARRAYFIRE_H
